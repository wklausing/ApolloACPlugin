\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\usepackage{listings}
\lstset{
language=C,
basicstyle=\small\sffamily,
numbers=left,
numberstyle=\tiny,
frame=tb,
xleftmargin=10pt,
xrightmargin=10pt,
columns=fullflexible,
showstringspaces=false
}
\begin{document}

\title{Advanced Access Control in GraphQL\\}

\author{\IEEEauthorblockN{Jaber, Amin Fayeq Nimer}
\IEEEauthorblockA{
\textit{TU Berlin}\\
amin.jaber@campus.tu-berlin.de}
\and
\IEEEauthorblockN{Klausing, Wilke}
\IEEEauthorblockA{
\textit{TU Berlin}\\
klausing@campus.tu-berlin.de}
\and
\IEEEauthorblockN{Nguyen, Huy Viet}
\IEEEauthorblockA{
\textit{TU Berlin}\\
huy.v.nguyen@campus.tu-berlin.de}
}

\maketitle

\begin{abstract}
GraphQL is a query language for reading and mutating data in APIs. It provides the back-end developer a type system to describe a data schema. This in turn gives front-end developers of the API the power to request the exact data they need. Although GraphQL is perceived as 'the successor of the good old REST', there is no widely established way to easily implement access control in GraphQL APIs. In this paper we will give a deeper insight to GraphQL, touch on different access control models that are common practice, show existing technologies that enable access control in GraphQL and introduce a new way to allow purposed-based access control in GraphQL which goes beyond traditional, account- or role-based access control.

\end{abstract}

\begin{IEEEkeywords}
Privacy Engineering, Access Control, GraphQL, Apollo Server
\end{IEEEkeywords}

\section{Introduction}\label{intro}
Write what this paper is about and what topics will be introduced in each chapter.

\section{What is GraphQL?}\label{basic}

Graph Query Language or short GraphQL is a query language and server-side runtime developed by Facebook in 2012. At first it was an internal project to help to increase the performance of its mobile apps, which suffered from more and more complexity. Especially the news feed required a lot of queries to the server, GraphQL solved this by offering more flexibility and efficiency. It supports not just query operations but mutations as well and is available in any language since it is only a specification. In 2015, Facebook published GraphQL to the public as an open-source project under the MIT licence. The GraphQL Foundation, which is part of the Linux Foundation, takes care of further developments. (4)

\subsection{How does GraphQL works?}\label{graphql}

A mayor concept of GraphQL is to think about data not in terms of resource URLs or tables but rather as a graph of objects. The client formulates queries, mutations or subscriptions to the server. Queries are used to retrieve data from the server, whereas mutations are used to change data within a predefined schema. Subscriptions command the server to push a notification to the client if some specific data changes. While queries and mutations use HTTP protocol for data transfer, does subscription require a web socket with a constant connection between server and client. (2)

If a client wants to make a query request it needs to send a HTTP GET or POST request to the endpoint, which is usually called /graphql. Each request contains a query which looks similar to a JSON object. Fields which are filled are used as search parameters to find the empty fields, which the client asked for. The fields are static types. Here you can see how a query can look like, with the respective answer on the right side. (3)
 
 #!!!Picture of Querie!!!#
 
For GET requests is the query encoded in the URL. This can look like the following example URL: http://localhost:8080/graphql?query={...}&variables={...}&operation=... . When POST is used the query is put into the request body. (3)

On the server side, when receiving the requests, it needs to be parsed, processed and answered accordingly. Parsing and answering are defined in the GraphQL protocols and are greatly standardized. For these steps’ libraries are widely available in many programming languages for different platforms. The process step, on the other hand, needs to be defined by the developer. Where the data comes from and what to include or exclude cannot be standardized because this highly depends on the use case. For each field that needs to be filled one resolver is used. The resolver is basically a function to get the data. Where the data comes is up the implementation by the developer. It could, for instance, be a text file, database, or from a data object which is stored in memory. For a good performance the resolvers are executed in parallel, if possible, instead of sequentially. To avoid several requests to the same source, resolver share resources between each other. (2)

\subsection{GraphQL vs Restful}\label{graphql}

The prior standard for web APIs before GraphQL is call RESTful API. It was introduced in 2000 in order to simplify the communication between machines using the HTTP protocol without any additional layers. This chapter will compare both APIs. (5)

A first difference is that GraphQL, in contrast to RESTful, uses only one endpoint. RESTful offers one endpoint for each data. For instance, RESTful saves Person data at the endpoint /person, while Tax data is saved at the endpoint /tax. This leads to problem called Overfetching and Underfetching. Overfetching refers to the problem that more data is fetched then the client asked for. For instance, if a client needs to fetch the name of a person it can fetch from endpoint /person. The response would be a JSON object that can contain also information like birthday, address or age. Underfetching refers to the problem that one endpoint does not contain all the information. The client needs to make several request to the server to get all the data it wanted in the first place. (1)

\subsection{Wilke Temp Lib}\label{graphql}

1.	https://www.howtographql.com/basics/1-graphql-is-the-better-rest/ \newline 
2.	https://www.heise.de/developer/artikel/Was-man-ueber-GraphQL-wissen-sollte-4997158.html \newline 
3.	https://graphql.org/learn/queries/#fields \newline 
4.	https://www.ionos.de/digitalguide/websites/web-entwicklung/graphql/ \newline 
5.	https://www.moesif.com/blog/technical/graphql/REST-vs-GraphQL-APIs-the-good-the-bad-the-ugly/ \newline 


\subsection{Privacy Engineering}\label{privacy}

The general definition of privacy:
Privacy is a part of our life as an individual, where a person can exercise an overall control over their own data like the use and distribution of any Personally Identifiable Information \boldsymbol{(PII)}. The increasingly privacy’s issue that are caused by the use, collection and maintenance of these private information.
\newline The short \boldsymbol{(PII)} stands for “information which can be used to distinguish or trace an individual’s identity, such as their name, social security number, bio-metric records, etc.”
\newline The main focus of privacy engineering is to combine privacy concepts in to already existing systems engineering processes for like the \boldsymbol{V model} (also known as water fall model), without creating an new step process in the model. On the image below the illustration shows how the main concepts of the privacy engineering are applied on such a model

\subsection{difference between privacy and security}\label{privacy and security}

The privacy as its definition defined is on an individual level, where an individual person can exercise an overall control on their own data \boldsymbol{(PII)}, while security is the mechanisms with the objective to protect these information and ensure its confidentiality, integrity and availability at all time. And from the concept of privacy and security together, our main focus will be on specific IT controls, which have the objective to ensure confidentiality and integrity of the information, while at the same time covering the privacy objectives. For example having an access controls system to ensure that only persons with authorization have the access permission to an individual information, whether it is for deleting, modifying or reading. Access control like this can help to achieve the integrity and confidentially of our information. In depth what access control can provide is to ensure that an individual with the specific authorizations have access to particular information with limited controls over them. With these methods we can protect our information from any unauthorized access while keeping them also safe.


\subsection{Access Control}\label{access_control}

The first objective of an access control is to identify the user, who is trying to execute a certain action, then grand them the authentication or not after looking in their identification can be a special ID number, in the end if this user get authorized, it will be only for specified limit the user have access to nothing more. In simpler words we can assume that a user used their username and password to get access to a network or library, while the users have access to it, but it is in a limited manner, like reading only with no permission to edit or delete. And this is where the Access control model come in to the play.
\newline
\newline There are several Access control model out in the world and here are a list of the four most common types: \newline
\begin{enumerate}
1.	Mandatory Access Control (MAC)\newline
2.	Role-Based Access Control (RBAC)\newline
3.	Discretionary Access Control (DAC)\newline
4.	Rule-Based Access Control (RBAC or RB-RBAC)\newline
\end{enumerate}
\newline
\subsubsection{	Mandatory Access Control (MAC)}\label{(MAC)}
\newline
In the Mandatory Access Control (MAC) model it gives the owner and the management level the complete access control of the system. Where the regular user could be employees have no control over any sittings unless they got granted by the owner. The MAC model have also two security models associated with it Biba and Bell-LaPadula. The Biba model main objective is focused on the integrity of the data, in addition that the users with lower level of permissions can only read from the users (owner/management) with higher level of permissions, it is also called (read up). While the user with higher level of permissions can write for the lower users, this called (write down). This is typically used in most companies where the manager team write down to the other employee’s their instructions and the employees only reads it.
\newline
The main focus of the second integrated model Bell-LaPadula model is confidentiality of information. Where the higher level users can only write to the same level of users (write up), but also read from the lower level of users (read down). Bell-LaPadula model was mostly used for government propose, since it is in a way, where if you don’t have access to a certain information’s, this should means you don´t need it. Formerly, MAC was linked with the numbering system, where each level of users are given certain number and same to the files data. For example a file (myfileXD) have the level number of 300 and another file (mylifelol) have the level number 500, an employee with level number 400 can have access to the file (myfileXD), since the user level is above 300 but not to the file (mylifelol), where it is lower. MAC still considered the highest access control there is for the reason as explained previously.
\newline
\subsubsection{Role-Based Access Control (RBAC)}\label{(RBAC)}
\newline
The Role-Based Access Control (RBAC) model provide access to the user depending of their position. Like for example if a user is in the security department, this user have already have its access permission associated to their position. With this method strategy of accessing information make life easier for company to manage their access rights for the employee, but the down side in this model is, if a user in some position needs access to another information in another position, then this user have to find other ways to get these information’s, otherwise this could lead to unauthorized access from another organizations.
\newline
\subsubsection{Discretionary Access Control (DAC)}\label{(DAC)}
\newline
The Discretionary Access Control (DAC), is the least limited constrain model, when compared with the MAC model, since it gives the user the complete access to any objective alongside any linked programs to that objectives. And this puts the DAC model having two crucial weaknesses. The first would be, granting an end user the total access control, where they can set the security settings level, for example by giving other user high or low levels setting and this can lead to access information’s they were not supposed to view. The second major weakness would be that the end user who have this total privileges are unknowingly inheriting onto other programs they execute, in other words the user can execute a malware in to the system and compromising it due to the user with high privileges’.
\newline
\subsubsection{Rule-Based Access Control (RBAC or RB-RBAC)}\label{(RBAC)}
\newline
The fourth and final access control model is Rule-Based Access Control, also with the acronym RBAC or RB-RBAC. Rule-Based Access Control will dynamically assign roles to users based on criteria defined by the custodian or system administrator. For example, if someone is only allowed access to files during certain hours of the day, Rule-Based Access Control would be the tool of choice. The additional “rules” of Rule-Based Access Control requiring implementation may need to be “programmed” into the network by the custodian or system administrator in the form of code versus “checking the box.”

\section{Existing Technologies}\label{ex_tech}

This chapter will introduce two APIs that are used for access control for current GraphQL frameworks. GraphQL Shield, which creates an additional permission layer on top of existing GraphQL APIs and GraphQL Filter which enables the back-end developer to filter the output of processed requests.

\subsection{GraphQL Shield}\label{shield}

GraphQL Shield is based on GraphQL Middleware which makes it possible to run arbitrary code before or after a GraphQL resolver is invoked. The Shield API was made to create field, type and role-based access control for any GraphQL and is compatible with all JavaScript GraphQL servers. The GraphQL Shield can be added into existing GraphQL Servers via GraphQL Middleware:

\begin{lstlisting}[label=some-code,caption=Integration \cite{b1}]
// Permissions...

// Apply permissions middleware with applyMiddleware
// Giving any schema (instance of GraphQLSchema)

import { applyMiddleware } from 'graphql-middleware'
// schema definition...
schema = applyMiddleware(schema, permissions)
\end{lstlisting}

And rules can be set by using logical operations: OR, AND, NOT, CHAIN (rules will be executed one by one until one fails or all pass) and RACE (chain rules, execution stops once one of them returns true). An example of how role-based access control works with GraphQL Shield can be seen in Listing \ref{example} .

\label{example}
\begin{lstlisting}[label=example,caption=Role-based Access Control \cite{b1}]
import { shield, rule, and, or } from 'graphql-shield'

const isAdmin = rule()(async (parent, args, ctx, info) => {
  return ctx.user.role === 'admin'
})

const isEditor = rule()(async (parent, args, ctx, info) => {
  return ctx.user.role === 'editor'
})

const isOwner = rule()(async (parent, args, ctx, info) => {
  return ctx.user.items.some((id) => id === parent.id)
})

const permissions = shield({
  Query: {
    users: or(isAdmin, isEditor),
  },
  Mutation: {
    createBlogPost: or(isAdmin, and(isOwner, isEditor)),
  },
  User: {
    secret: isOwner,
  },
})
\end{lstlisting}

The code in Listing \ref{example} defines the following rules for a certain blog:

\begin{itemize}
    \item Only an editor or an admin can see a list of all users
    \item Only an admin or an owner with an editor role can create blog posts
    \item Only the owner of the blog can see user's secrets
\end{itemize}


\subsection{GraphQL Filter}\label{filter}

GraphQL Filter is another API that was created based on GraphQL Middleware. It allows to set specific types private. The API is said to provide an additional privacy layer to GraphQL and replaces private information before the query result is sent back to the client. The API is the only framework apart from GraphQL Shield that provides access control for GraphQL as of now. There is no documentation available. There is one test case to showcase how to integrate GraphQL Filter into existing systems. The developer designed it in order to create a more flexible privacy control:\newline

 \begin{quote} ''It may be able to implement flexible read control with graphql-filter and graphql-shield.'' \cite{b2}\newline
 \end{quote}

The lack of available APIs for access control in GraphQL shows the relevance of this paper's topic and a real need for a re-useable component that allows developers to easily add access control into their systems.

\section{Approach}\label{approach}

TODO (introduce our idea)

\begin{thebibliography}{00}
\bibitem{b1} Zavadlal, M., 2021. maticzav/graphql-shield. [online] GitHub. Available at: <https://github.com/maticzav/graphql-shield> [Accessed 9 May 2021].
\bibitem{b2} Hata, T., 2021. hata6502/graphql-filter. [online] GitHub. Available at: <https://github.com/hata6502/graphql-filter> [Accessed 11 May 2021].
\bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
\bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
\bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
\bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
\bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
\end{thebibliography}

\end{document}
